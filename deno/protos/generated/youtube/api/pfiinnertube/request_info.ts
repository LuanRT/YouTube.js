// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.29.2
// source: youtube/api/pfiinnertube/request_info.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "https://esm.sh/@bufbuild/protobuf@2.0.0/wire";
import { KeyValuePair } from "../../../misc/common.ts";
import { AttestationResponseData } from "./attestation_response_data.ts";

export const protobufPackage = "youtube.api.pfiinnertube";

export interface RequestInfo {
  thirdPartyDigest?: string | undefined;
  useSsl?: boolean | undefined;
  returnErrorDetail?:
    | boolean
    | undefined;
  /** "If-None-Match" HTTP header? */
  ifNoneMatch?: string | undefined;
  returnLogEntry?: boolean | undefined;
  isPrefetch?: boolean | undefined;
  internalExperimentFlags: KeyValuePair[];
  returnDebugData?: boolean | undefined;
  innertubez?: string | undefined;
  traceProto?: boolean | undefined;
  returnLogEntryJson?: boolean | undefined;
  sherlogUsername?:
    | string
    | undefined;
  /** repeated ConsistencyTokenJar consistency_token_jars = 26; */
  reauthRequestInfo?: RequestInfo_ReauthRequestInfo | undefined;
  sessionInfo?: RequestInfo_SessionInfo | undefined;
  returnLogEntryProto?:
    | boolean
    | undefined;
  /** External pre-request context as a string */
  externalPrequestContext?:
    | string
    | undefined;
  /**
   * repeated InnerTubeTokenJar innertube_token_jar = 33;
   * Would a botguard/droidguard response here allow playback?
   */
  attestationResponseData?: AttestationResponseData | undefined;
  eats?: Uint8Array | undefined;
  requestQos?: RequestInfo_RequestQoS | undefined;
}

export enum RequestInfo_Criticality {
  CRITICALITY_UNSPECIFIED = 0,
  CRITICALITY_CRITICAL = 1,
  CRITICALITY_NON_CRITICAL = 2,
  UNRECOGNIZED = -1,
}

/** Quality of Service? */
export interface RequestInfo_RequestQoS {
  criticality?: RequestInfo_Criticality | undefined;
}

export interface RequestInfo_SessionInfo {
  token?: string | undefined;
}

export interface RequestInfo_ReauthRequestInfo {
  encodedReauthProofToken?: string | undefined;
}

function createBaseRequestInfo(): RequestInfo {
  return {
    thirdPartyDigest: undefined,
    useSsl: undefined,
    returnErrorDetail: undefined,
    ifNoneMatch: undefined,
    returnLogEntry: undefined,
    isPrefetch: undefined,
    internalExperimentFlags: [],
    returnDebugData: undefined,
    innertubez: undefined,
    traceProto: undefined,
    returnLogEntryJson: undefined,
    sherlogUsername: undefined,
    reauthRequestInfo: undefined,
    sessionInfo: undefined,
    returnLogEntryProto: undefined,
    externalPrequestContext: undefined,
    attestationResponseData: undefined,
    eats: undefined,
    requestQos: undefined,
  };
}

export const RequestInfo: MessageFns<RequestInfo> = {
  encode(message: RequestInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.thirdPartyDigest !== undefined) {
      writer.uint32(50).string(message.thirdPartyDigest);
    }
    if (message.useSsl !== undefined) {
      writer.uint32(56).bool(message.useSsl);
    }
    if (message.returnErrorDetail !== undefined) {
      writer.uint32(72).bool(message.returnErrorDetail);
    }
    if (message.ifNoneMatch !== undefined) {
      writer.uint32(98).string(message.ifNoneMatch);
    }
    if (message.returnLogEntry !== undefined) {
      writer.uint32(104).bool(message.returnLogEntry);
    }
    if (message.isPrefetch !== undefined) {
      writer.uint32(112).bool(message.isPrefetch);
    }
    for (const v of message.internalExperimentFlags) {
      KeyValuePair.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.returnDebugData !== undefined) {
      writer.uint32(128).bool(message.returnDebugData);
    }
    if (message.innertubez !== undefined) {
      writer.uint32(146).string(message.innertubez);
    }
    if (message.traceProto !== undefined) {
      writer.uint32(184).bool(message.traceProto);
    }
    if (message.returnLogEntryJson !== undefined) {
      writer.uint32(192).bool(message.returnLogEntryJson);
    }
    if (message.sherlogUsername !== undefined) {
      writer.uint32(202).string(message.sherlogUsername);
    }
    if (message.reauthRequestInfo !== undefined) {
      RequestInfo_ReauthRequestInfo.encode(message.reauthRequestInfo, writer.uint32(234).fork()).join();
    }
    if (message.sessionInfo !== undefined) {
      RequestInfo_SessionInfo.encode(message.sessionInfo, writer.uint32(242).fork()).join();
    }
    if (message.returnLogEntryProto !== undefined) {
      writer.uint32(248).bool(message.returnLogEntryProto);
    }
    if (message.externalPrequestContext !== undefined) {
      writer.uint32(258).string(message.externalPrequestContext);
    }
    if (message.attestationResponseData !== undefined) {
      AttestationResponseData.encode(message.attestationResponseData, writer.uint32(274).fork()).join();
    }
    if (message.eats !== undefined) {
      writer.uint32(282).bytes(message.eats);
    }
    if (message.requestQos !== undefined) {
      RequestInfo_RequestQoS.encode(message.requestQos, writer.uint32(290).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.thirdPartyDigest = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.useSsl = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.returnErrorDetail = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.ifNoneMatch = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.returnLogEntry = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.isPrefetch = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.internalExperimentFlags.push(KeyValuePair.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.returnDebugData = reader.bool();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.innertubez = reader.string();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.traceProto = reader.bool();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.returnLogEntryJson = reader.bool();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.sherlogUsername = reader.string();
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.reauthRequestInfo = RequestInfo_ReauthRequestInfo.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.sessionInfo = RequestInfo_SessionInfo.decode(reader, reader.uint32());
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.returnLogEntryProto = reader.bool();
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.externalPrequestContext = reader.string();
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.attestationResponseData = AttestationResponseData.decode(reader, reader.uint32());
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.eats = reader.bytes();
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.requestQos = RequestInfo_RequestQoS.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRequestInfo_RequestQoS(): RequestInfo_RequestQoS {
  return { criticality: undefined };
}

export const RequestInfo_RequestQoS: MessageFns<RequestInfo_RequestQoS> = {
  encode(message: RequestInfo_RequestQoS, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.criticality !== undefined) {
      writer.uint32(8).int32(message.criticality);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestInfo_RequestQoS {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestInfo_RequestQoS();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.criticality = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRequestInfo_SessionInfo(): RequestInfo_SessionInfo {
  return { token: undefined };
}

export const RequestInfo_SessionInfo: MessageFns<RequestInfo_SessionInfo> = {
  encode(message: RequestInfo_SessionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== undefined) {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestInfo_SessionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestInfo_SessionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRequestInfo_ReauthRequestInfo(): RequestInfo_ReauthRequestInfo {
  return { encodedReauthProofToken: undefined };
}

export const RequestInfo_ReauthRequestInfo: MessageFns<RequestInfo_ReauthRequestInfo> = {
  encode(message: RequestInfo_ReauthRequestInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encodedReauthProofToken !== undefined) {
      writer.uint32(10).string(message.encodedReauthProofToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestInfo_ReauthRequestInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestInfo_ReauthRequestInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.encodedReauthProofToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
