// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.28.0
// source: youtube/api/pfiinnertube/request_info.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { KeyValuePair } from "../../../misc/common.js";
import { AttestationResponseData } from "./attestation_response_data.js";

export const protobufPackage = "youtube.api.pfiinnertube";

export interface RequestInfo {
  thirdPartyDigest?: string | undefined;
  useSsl?: boolean | undefined;
  returnErrorDetail?:
    | boolean
    | undefined;
  /** "If-None-Match" HTTP header? */
  ifNoneMatch?: string | undefined;
  returnLogEntry?: boolean | undefined;
  isPrefetch?: boolean | undefined;
  internalExperimentFlags: KeyValuePair[];
  returnDebugData?: boolean | undefined;
  innertubez?: string | undefined;
  traceProto?: boolean | undefined;
  returnLogEntryJson?: boolean | undefined;
  sherlogUsername?:
    | string
    | undefined;
  /** repeated ConsistencyTokenJar consistency_token_jars = 26; */
  reauthRequestInfo?: RequestInfo_ReauthRequestInfo | undefined;
  sessionInfo?: RequestInfo_SessionInfo | undefined;
  returnLogEntryProto?:
    | boolean
    | undefined;
  /** External pre-request context as a string */
  externalPrequestContext?:
    | string
    | undefined;
  /**
   * repeated InnerTubeTokenJar innertube_token_jar = 33;
   * Would a botguard/droidguard response here allow playback?
   */
  attestationResponseData?: AttestationResponseData | undefined;
  eats?: Uint8Array | undefined;
  requestQos?: RequestInfo_RequestQoS | undefined;
}

export enum RequestInfo_Criticality {
  CRITICALITY_UNSPECIFIED = 0,
  CRITICALITY_CRITICAL = 1,
  CRITICALITY_NON_CRITICAL = 2,
  UNRECOGNIZED = -1,
}

export function requestInfo_CriticalityFromJSON(object: any): RequestInfo_Criticality {
  switch (object) {
    case 0:
    case "CRITICALITY_UNSPECIFIED":
      return RequestInfo_Criticality.CRITICALITY_UNSPECIFIED;
    case 1:
    case "CRITICALITY_CRITICAL":
      return RequestInfo_Criticality.CRITICALITY_CRITICAL;
    case 2:
    case "CRITICALITY_NON_CRITICAL":
      return RequestInfo_Criticality.CRITICALITY_NON_CRITICAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RequestInfo_Criticality.UNRECOGNIZED;
  }
}

export function requestInfo_CriticalityToJSON(object: RequestInfo_Criticality): string {
  switch (object) {
    case RequestInfo_Criticality.CRITICALITY_UNSPECIFIED:
      return "CRITICALITY_UNSPECIFIED";
    case RequestInfo_Criticality.CRITICALITY_CRITICAL:
      return "CRITICALITY_CRITICAL";
    case RequestInfo_Criticality.CRITICALITY_NON_CRITICAL:
      return "CRITICALITY_NON_CRITICAL";
    case RequestInfo_Criticality.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Quality of Service? */
export interface RequestInfo_RequestQoS {
  criticality?: RequestInfo_Criticality | undefined;
}

export interface RequestInfo_SessionInfo {
  token?: string | undefined;
}

export interface RequestInfo_ReauthRequestInfo {
  encodedReauthProofToken?: string | undefined;
}

function createBaseRequestInfo(): RequestInfo {
  return {
    thirdPartyDigest: undefined,
    useSsl: undefined,
    returnErrorDetail: undefined,
    ifNoneMatch: undefined,
    returnLogEntry: undefined,
    isPrefetch: undefined,
    internalExperimentFlags: [],
    returnDebugData: undefined,
    innertubez: undefined,
    traceProto: undefined,
    returnLogEntryJson: undefined,
    sherlogUsername: undefined,
    reauthRequestInfo: undefined,
    sessionInfo: undefined,
    returnLogEntryProto: undefined,
    externalPrequestContext: undefined,
    attestationResponseData: undefined,
    eats: undefined,
    requestQos: undefined,
  };
}

export const RequestInfo: MessageFns<RequestInfo> = {
  encode(message: RequestInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.thirdPartyDigest !== undefined) {
      writer.uint32(50).string(message.thirdPartyDigest);
    }
    if (message.useSsl !== undefined) {
      writer.uint32(56).bool(message.useSsl);
    }
    if (message.returnErrorDetail !== undefined) {
      writer.uint32(72).bool(message.returnErrorDetail);
    }
    if (message.ifNoneMatch !== undefined) {
      writer.uint32(98).string(message.ifNoneMatch);
    }
    if (message.returnLogEntry !== undefined) {
      writer.uint32(104).bool(message.returnLogEntry);
    }
    if (message.isPrefetch !== undefined) {
      writer.uint32(112).bool(message.isPrefetch);
    }
    for (const v of message.internalExperimentFlags) {
      KeyValuePair.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.returnDebugData !== undefined) {
      writer.uint32(128).bool(message.returnDebugData);
    }
    if (message.innertubez !== undefined) {
      writer.uint32(146).string(message.innertubez);
    }
    if (message.traceProto !== undefined) {
      writer.uint32(184).bool(message.traceProto);
    }
    if (message.returnLogEntryJson !== undefined) {
      writer.uint32(192).bool(message.returnLogEntryJson);
    }
    if (message.sherlogUsername !== undefined) {
      writer.uint32(202).string(message.sherlogUsername);
    }
    if (message.reauthRequestInfo !== undefined) {
      RequestInfo_ReauthRequestInfo.encode(message.reauthRequestInfo, writer.uint32(234).fork()).join();
    }
    if (message.sessionInfo !== undefined) {
      RequestInfo_SessionInfo.encode(message.sessionInfo, writer.uint32(242).fork()).join();
    }
    if (message.returnLogEntryProto !== undefined) {
      writer.uint32(248).bool(message.returnLogEntryProto);
    }
    if (message.externalPrequestContext !== undefined) {
      writer.uint32(258).string(message.externalPrequestContext);
    }
    if (message.attestationResponseData !== undefined) {
      AttestationResponseData.encode(message.attestationResponseData, writer.uint32(274).fork()).join();
    }
    if (message.eats !== undefined) {
      writer.uint32(282).bytes(message.eats);
    }
    if (message.requestQos !== undefined) {
      RequestInfo_RequestQoS.encode(message.requestQos, writer.uint32(290).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.thirdPartyDigest = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.useSsl = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.returnErrorDetail = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.ifNoneMatch = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.returnLogEntry = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.isPrefetch = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.internalExperimentFlags.push(KeyValuePair.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.returnDebugData = reader.bool();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.innertubez = reader.string();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.traceProto = reader.bool();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.returnLogEntryJson = reader.bool();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.sherlogUsername = reader.string();
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.reauthRequestInfo = RequestInfo_ReauthRequestInfo.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.sessionInfo = RequestInfo_SessionInfo.decode(reader, reader.uint32());
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.returnLogEntryProto = reader.bool();
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.externalPrequestContext = reader.string();
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.attestationResponseData = AttestationResponseData.decode(reader, reader.uint32());
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.eats = reader.bytes();
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.requestQos = RequestInfo_RequestQoS.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestInfo {
    return {
      thirdPartyDigest: isSet(object.thirdPartyDigest) ? globalThis.String(object.thirdPartyDigest) : undefined,
      useSsl: isSet(object.useSsl) ? globalThis.Boolean(object.useSsl) : undefined,
      returnErrorDetail: isSet(object.returnErrorDetail) ? globalThis.Boolean(object.returnErrorDetail) : undefined,
      ifNoneMatch: isSet(object.ifNoneMatch) ? globalThis.String(object.ifNoneMatch) : undefined,
      returnLogEntry: isSet(object.returnLogEntry) ? globalThis.Boolean(object.returnLogEntry) : undefined,
      isPrefetch: isSet(object.isPrefetch) ? globalThis.Boolean(object.isPrefetch) : undefined,
      internalExperimentFlags: globalThis.Array.isArray(object?.internalExperimentFlags)
        ? object.internalExperimentFlags.map((e: any) => KeyValuePair.fromJSON(e))
        : [],
      returnDebugData: isSet(object.returnDebugData) ? globalThis.Boolean(object.returnDebugData) : undefined,
      innertubez: isSet(object.innertubez) ? globalThis.String(object.innertubez) : undefined,
      traceProto: isSet(object.traceProto) ? globalThis.Boolean(object.traceProto) : undefined,
      returnLogEntryJson: isSet(object.returnLogEntryJson) ? globalThis.Boolean(object.returnLogEntryJson) : undefined,
      sherlogUsername: isSet(object.sherlogUsername) ? globalThis.String(object.sherlogUsername) : undefined,
      reauthRequestInfo: isSet(object.reauthRequestInfo)
        ? RequestInfo_ReauthRequestInfo.fromJSON(object.reauthRequestInfo)
        : undefined,
      sessionInfo: isSet(object.sessionInfo) ? RequestInfo_SessionInfo.fromJSON(object.sessionInfo) : undefined,
      returnLogEntryProto: isSet(object.returnLogEntryProto)
        ? globalThis.Boolean(object.returnLogEntryProto)
        : undefined,
      externalPrequestContext: isSet(object.externalPrequestContext)
        ? globalThis.String(object.externalPrequestContext)
        : undefined,
      attestationResponseData: isSet(object.attestationResponseData)
        ? AttestationResponseData.fromJSON(object.attestationResponseData)
        : undefined,
      eats: isSet(object.eats) ? bytesFromBase64(object.eats) : undefined,
      requestQos: isSet(object.requestQos) ? RequestInfo_RequestQoS.fromJSON(object.requestQos) : undefined,
    };
  },

  toJSON(message: RequestInfo): unknown {
    const obj: any = {};
    if (message.thirdPartyDigest !== undefined) {
      obj.thirdPartyDigest = message.thirdPartyDigest;
    }
    if (message.useSsl !== undefined) {
      obj.useSsl = message.useSsl;
    }
    if (message.returnErrorDetail !== undefined) {
      obj.returnErrorDetail = message.returnErrorDetail;
    }
    if (message.ifNoneMatch !== undefined) {
      obj.ifNoneMatch = message.ifNoneMatch;
    }
    if (message.returnLogEntry !== undefined) {
      obj.returnLogEntry = message.returnLogEntry;
    }
    if (message.isPrefetch !== undefined) {
      obj.isPrefetch = message.isPrefetch;
    }
    if (message.internalExperimentFlags?.length) {
      obj.internalExperimentFlags = message.internalExperimentFlags.map((e) => KeyValuePair.toJSON(e));
    }
    if (message.returnDebugData !== undefined) {
      obj.returnDebugData = message.returnDebugData;
    }
    if (message.innertubez !== undefined) {
      obj.innertubez = message.innertubez;
    }
    if (message.traceProto !== undefined) {
      obj.traceProto = message.traceProto;
    }
    if (message.returnLogEntryJson !== undefined) {
      obj.returnLogEntryJson = message.returnLogEntryJson;
    }
    if (message.sherlogUsername !== undefined) {
      obj.sherlogUsername = message.sherlogUsername;
    }
    if (message.reauthRequestInfo !== undefined) {
      obj.reauthRequestInfo = RequestInfo_ReauthRequestInfo.toJSON(message.reauthRequestInfo);
    }
    if (message.sessionInfo !== undefined) {
      obj.sessionInfo = RequestInfo_SessionInfo.toJSON(message.sessionInfo);
    }
    if (message.returnLogEntryProto !== undefined) {
      obj.returnLogEntryProto = message.returnLogEntryProto;
    }
    if (message.externalPrequestContext !== undefined) {
      obj.externalPrequestContext = message.externalPrequestContext;
    }
    if (message.attestationResponseData !== undefined) {
      obj.attestationResponseData = AttestationResponseData.toJSON(message.attestationResponseData);
    }
    if (message.eats !== undefined) {
      obj.eats = base64FromBytes(message.eats);
    }
    if (message.requestQos !== undefined) {
      obj.requestQos = RequestInfo_RequestQoS.toJSON(message.requestQos);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestInfo>, I>>(base?: I): RequestInfo {
    return RequestInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestInfo>, I>>(object: I): RequestInfo {
    const message = createBaseRequestInfo();
    message.thirdPartyDigest = object.thirdPartyDigest ?? undefined;
    message.useSsl = object.useSsl ?? undefined;
    message.returnErrorDetail = object.returnErrorDetail ?? undefined;
    message.ifNoneMatch = object.ifNoneMatch ?? undefined;
    message.returnLogEntry = object.returnLogEntry ?? undefined;
    message.isPrefetch = object.isPrefetch ?? undefined;
    message.internalExperimentFlags = object.internalExperimentFlags?.map((e) => KeyValuePair.fromPartial(e)) || [];
    message.returnDebugData = object.returnDebugData ?? undefined;
    message.innertubez = object.innertubez ?? undefined;
    message.traceProto = object.traceProto ?? undefined;
    message.returnLogEntryJson = object.returnLogEntryJson ?? undefined;
    message.sherlogUsername = object.sherlogUsername ?? undefined;
    message.reauthRequestInfo = (object.reauthRequestInfo !== undefined && object.reauthRequestInfo !== null)
      ? RequestInfo_ReauthRequestInfo.fromPartial(object.reauthRequestInfo)
      : undefined;
    message.sessionInfo = (object.sessionInfo !== undefined && object.sessionInfo !== null)
      ? RequestInfo_SessionInfo.fromPartial(object.sessionInfo)
      : undefined;
    message.returnLogEntryProto = object.returnLogEntryProto ?? undefined;
    message.externalPrequestContext = object.externalPrequestContext ?? undefined;
    message.attestationResponseData =
      (object.attestationResponseData !== undefined && object.attestationResponseData !== null)
        ? AttestationResponseData.fromPartial(object.attestationResponseData)
        : undefined;
    message.eats = object.eats ?? undefined;
    message.requestQos = (object.requestQos !== undefined && object.requestQos !== null)
      ? RequestInfo_RequestQoS.fromPartial(object.requestQos)
      : undefined;
    return message;
  },
};

function createBaseRequestInfo_RequestQoS(): RequestInfo_RequestQoS {
  return { criticality: undefined };
}

export const RequestInfo_RequestQoS: MessageFns<RequestInfo_RequestQoS> = {
  encode(message: RequestInfo_RequestQoS, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.criticality !== undefined) {
      writer.uint32(8).int32(message.criticality);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestInfo_RequestQoS {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestInfo_RequestQoS();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.criticality = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestInfo_RequestQoS {
    return { criticality: isSet(object.criticality) ? requestInfo_CriticalityFromJSON(object.criticality) : undefined };
  },

  toJSON(message: RequestInfo_RequestQoS): unknown {
    const obj: any = {};
    if (message.criticality !== undefined) {
      obj.criticality = requestInfo_CriticalityToJSON(message.criticality);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestInfo_RequestQoS>, I>>(base?: I): RequestInfo_RequestQoS {
    return RequestInfo_RequestQoS.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestInfo_RequestQoS>, I>>(object: I): RequestInfo_RequestQoS {
    const message = createBaseRequestInfo_RequestQoS();
    message.criticality = object.criticality ?? undefined;
    return message;
  },
};

function createBaseRequestInfo_SessionInfo(): RequestInfo_SessionInfo {
  return { token: undefined };
}

export const RequestInfo_SessionInfo: MessageFns<RequestInfo_SessionInfo> = {
  encode(message: RequestInfo_SessionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== undefined) {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestInfo_SessionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestInfo_SessionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestInfo_SessionInfo {
    return { token: isSet(object.token) ? globalThis.String(object.token) : undefined };
  },

  toJSON(message: RequestInfo_SessionInfo): unknown {
    const obj: any = {};
    if (message.token !== undefined) {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestInfo_SessionInfo>, I>>(base?: I): RequestInfo_SessionInfo {
    return RequestInfo_SessionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestInfo_SessionInfo>, I>>(object: I): RequestInfo_SessionInfo {
    const message = createBaseRequestInfo_SessionInfo();
    message.token = object.token ?? undefined;
    return message;
  },
};

function createBaseRequestInfo_ReauthRequestInfo(): RequestInfo_ReauthRequestInfo {
  return { encodedReauthProofToken: undefined };
}

export const RequestInfo_ReauthRequestInfo: MessageFns<RequestInfo_ReauthRequestInfo> = {
  encode(message: RequestInfo_ReauthRequestInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encodedReauthProofToken !== undefined) {
      writer.uint32(10).string(message.encodedReauthProofToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestInfo_ReauthRequestInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestInfo_ReauthRequestInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.encodedReauthProofToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestInfo_ReauthRequestInfo {
    return {
      encodedReauthProofToken: isSet(object.encodedReauthProofToken)
        ? globalThis.String(object.encodedReauthProofToken)
        : undefined,
    };
  },

  toJSON(message: RequestInfo_ReauthRequestInfo): unknown {
    const obj: any = {};
    if (message.encodedReauthProofToken !== undefined) {
      obj.encodedReauthProofToken = message.encodedReauthProofToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestInfo_ReauthRequestInfo>, I>>(base?: I): RequestInfo_ReauthRequestInfo {
    return RequestInfo_ReauthRequestInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestInfo_ReauthRequestInfo>, I>>(
    object: I,
  ): RequestInfo_ReauthRequestInfo {
    const message = createBaseRequestInfo_ReauthRequestInfo();
    message.encodedReauthProofToken = object.encodedReauthProofToken ?? undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
