// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.28.0
// source: misc/params.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "misc";

export interface VisitorData {
  id: string;
  timestamp: number;
}

export interface SearchFilter {
  sortBy?: SearchFilter_SortBy | undefined;
  filters?: SearchFilter_Filters | undefined;
}

export enum SearchFilter_SortBy {
  RELEVANCE = 0,
  RATING = 1,
  UPLOAD_DATE = 2,
  VIEW_COUNT = 3,
  UNRECOGNIZED = -1,
}

export interface SearchFilter_Filters {
  uploadDate?: SearchFilter_Filters_UploadDate | undefined;
  type?: SearchFilter_Filters_SearchType | undefined;
  duration?: SearchFilter_Filters_Duration | undefined;
  musicSearchType?: SearchFilter_Filters_MusicSearchType | undefined;
  featuresHd?: boolean | undefined;
  featuresSubtitles?: boolean | undefined;
  featuresCreativeCommons?: boolean | undefined;
  features3d?: boolean | undefined;
  featuresLive?: boolean | undefined;
  featuresPurchased?: boolean | undefined;
  features4k?: boolean | undefined;
  features360?: boolean | undefined;
  featuresLocation?: boolean | undefined;
  featuresHdr?: boolean | undefined;
  featuresVr180?: boolean | undefined;
}

export enum SearchFilter_Filters_UploadDate {
  ANY_DATE = 0,
  HOUR = 1,
  TODAY = 2,
  WEEK = 3,
  MONTH = 4,
  YEAR = 5,
  UNRECOGNIZED = -1,
}

export enum SearchFilter_Filters_SearchType {
  ANY_TYPE = 0,
  VIDEO = 1,
  CHANNEL = 2,
  PLAYLIST = 3,
  MOVIE = 4,
  UNRECOGNIZED = -1,
}

export enum SearchFilter_Filters_Duration {
  ANY_DURATION = 0,
  SHORT = 1,
  LONG = 2,
  MEDIUM = 3,
  UNRECOGNIZED = -1,
}

export interface SearchFilter_Filters_MusicSearchType {
  song?: boolean | undefined;
  video?: boolean | undefined;
  album?: boolean | undefined;
  artist?: boolean | undefined;
  playlist?: boolean | undefined;
}

export interface ChannelAnalytics {
  params: ChannelAnalytics_Params | undefined;
}

export interface ChannelAnalytics_Params {
  channelId: string;
}

export interface SoundInfoParams {
  sound: SoundInfoParams_Sound | undefined;
}

export interface SoundInfoParams_Sound {
  params: SoundInfoParams_Sound_Params | undefined;
}

export interface SoundInfoParams_Sound_Params {
  ids: SoundInfoParams_Sound_Params_Ids | undefined;
}

export interface SoundInfoParams_Sound_Params_Ids {
  id1: string;
  id2: string;
  id3: string;
}

export interface NotificationPreferences {
  channelId: string;
  prefId: NotificationPreferences_Preference | undefined;
  number0?: number | undefined;
  number1?: number | undefined;
}

export interface NotificationPreferences_Preference {
  index: number;
}

export interface LiveMessageParams {
  params: LiveMessageParams_Params | undefined;
  number0?: number | undefined;
  number1?: number | undefined;
}

export interface LiveMessageParams_Params {
  ids: LiveMessageParams_Params_Ids | undefined;
}

export interface LiveMessageParams_Params_Ids {
  channelId: string;
  videoId: string;
}

export interface GetCommentsSectionParams {
  ctx: GetCommentsSectionParams_Context | undefined;
  unkParam: number;
  params: GetCommentsSectionParams_Params | undefined;
}

export interface GetCommentsSectionParams_Context {
  videoId: string;
}

export interface GetCommentsSectionParams_Params {
  unkToken?: string | undefined;
  opts?: GetCommentsSectionParams_Params_Options | undefined;
  repliesOpts?: GetCommentsSectionParams_Params_RepliesOptions | undefined;
  page?: number | undefined;
  target: string;
}

export interface GetCommentsSectionParams_Params_Options {
  videoId: string;
  sortBy: number;
  type: number;
  commentId?: string | undefined;
}

export interface GetCommentsSectionParams_Params_RepliesOptions {
  commentId: string;
  unkopts: GetCommentsSectionParams_Params_RepliesOptions_UnkOpts | undefined;
  channelId?: string | undefined;
  videoId: string;
  unkParam1: number;
  unkParam2: number;
}

export interface GetCommentsSectionParams_Params_RepliesOptions_UnkOpts {
  unkParam: number;
}

export interface CreateCommentParams {
  videoId: string;
  params: CreateCommentParams_Params | undefined;
  number: number;
}

export interface CreateCommentParams_Params {
  index: number;
}

export interface PeformCommentActionParams {
  type: number;
  commentId: string;
  videoId: string;
  unkNum?: number | undefined;
  channelId?: string | undefined;
  translateCommentParams?: PeformCommentActionParams_TranslateCommentParams | undefined;
}

export interface PeformCommentActionParams_TranslateCommentParams {
  params: PeformCommentActionParams_TranslateCommentParams_Params | undefined;
  commentId: string;
  targetLanguage: string;
}

export interface PeformCommentActionParams_TranslateCommentParams_Params {
  comment: PeformCommentActionParams_TranslateCommentParams_Params_Comment | undefined;
}

export interface PeformCommentActionParams_TranslateCommentParams_Params_Comment {
  text: string;
}

export interface Hashtag {
  params: Hashtag_Params | undefined;
}

export interface Hashtag_Params {
  hashtag: string;
  type: number;
}

export interface ReelSequence {
  shortId: string;
  params: ReelSequence_Params | undefined;
  feature2: number;
  feature3: number;
}

export interface ReelSequence_Params {
  number: number;
}

export interface ShortsParam {
  f1?: ShortsParam_Field1 | undefined;
  p59?: number | undefined;
}

export interface ShortsParam_Field1 {
  p1?: number | undefined;
}

export interface NextParams {
  videoId: string[];
}

function createBaseVisitorData(): VisitorData {
  return { id: "", timestamp: 0 };
}

export const VisitorData: MessageFns<VisitorData> = {
  encode(message: VisitorData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.timestamp !== 0) {
      writer.uint32(40).int32(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VisitorData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVisitorData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.timestamp = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSearchFilter(): SearchFilter {
  return { sortBy: undefined, filters: undefined };
}

export const SearchFilter: MessageFns<SearchFilter> = {
  encode(message: SearchFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sortBy !== undefined) {
      writer.uint32(8).int32(message.sortBy);
    }
    if (message.filters !== undefined) {
      SearchFilter_Filters.encode(message.filters, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sortBy = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filters = SearchFilter_Filters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSearchFilter_Filters(): SearchFilter_Filters {
  return {
    uploadDate: undefined,
    type: undefined,
    duration: undefined,
    musicSearchType: undefined,
    featuresHd: undefined,
    featuresSubtitles: undefined,
    featuresCreativeCommons: undefined,
    features3d: undefined,
    featuresLive: undefined,
    featuresPurchased: undefined,
    features4k: undefined,
    features360: undefined,
    featuresLocation: undefined,
    featuresHdr: undefined,
    featuresVr180: undefined,
  };
}

export const SearchFilter_Filters: MessageFns<SearchFilter_Filters> = {
  encode(message: SearchFilter_Filters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uploadDate !== undefined) {
      writer.uint32(8).int32(message.uploadDate);
    }
    if (message.type !== undefined) {
      writer.uint32(16).int32(message.type);
    }
    if (message.duration !== undefined) {
      writer.uint32(24).int32(message.duration);
    }
    if (message.musicSearchType !== undefined) {
      SearchFilter_Filters_MusicSearchType.encode(message.musicSearchType, writer.uint32(138).fork()).join();
    }
    if (message.featuresHd !== undefined) {
      writer.uint32(32).bool(message.featuresHd);
    }
    if (message.featuresSubtitles !== undefined) {
      writer.uint32(40).bool(message.featuresSubtitles);
    }
    if (message.featuresCreativeCommons !== undefined) {
      writer.uint32(48).bool(message.featuresCreativeCommons);
    }
    if (message.features3d !== undefined) {
      writer.uint32(56).bool(message.features3d);
    }
    if (message.featuresLive !== undefined) {
      writer.uint32(64).bool(message.featuresLive);
    }
    if (message.featuresPurchased !== undefined) {
      writer.uint32(72).bool(message.featuresPurchased);
    }
    if (message.features4k !== undefined) {
      writer.uint32(112).bool(message.features4k);
    }
    if (message.features360 !== undefined) {
      writer.uint32(120).bool(message.features360);
    }
    if (message.featuresLocation !== undefined) {
      writer.uint32(184).bool(message.featuresLocation);
    }
    if (message.featuresHdr !== undefined) {
      writer.uint32(200).bool(message.featuresHdr);
    }
    if (message.featuresVr180 !== undefined) {
      writer.uint32(208).bool(message.featuresVr180);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchFilter_Filters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchFilter_Filters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.uploadDate = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.duration = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.musicSearchType = SearchFilter_Filters_MusicSearchType.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.featuresHd = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.featuresSubtitles = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.featuresCreativeCommons = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.features3d = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.featuresLive = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.featuresPurchased = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.features4k = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.features360 = reader.bool();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.featuresLocation = reader.bool();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.featuresHdr = reader.bool();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.featuresVr180 = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSearchFilter_Filters_MusicSearchType(): SearchFilter_Filters_MusicSearchType {
  return { song: undefined, video: undefined, album: undefined, artist: undefined, playlist: undefined };
}

export const SearchFilter_Filters_MusicSearchType: MessageFns<SearchFilter_Filters_MusicSearchType> = {
  encode(message: SearchFilter_Filters_MusicSearchType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.song !== undefined) {
      writer.uint32(8).bool(message.song);
    }
    if (message.video !== undefined) {
      writer.uint32(16).bool(message.video);
    }
    if (message.album !== undefined) {
      writer.uint32(24).bool(message.album);
    }
    if (message.artist !== undefined) {
      writer.uint32(32).bool(message.artist);
    }
    if (message.playlist !== undefined) {
      writer.uint32(40).bool(message.playlist);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchFilter_Filters_MusicSearchType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchFilter_Filters_MusicSearchType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.song = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.video = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.album = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.artist = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.playlist = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseChannelAnalytics(): ChannelAnalytics {
  return { params: undefined };
}

export const ChannelAnalytics: MessageFns<ChannelAnalytics> = {
  encode(message: ChannelAnalytics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      ChannelAnalytics_Params.encode(message.params, writer.uint32(258).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelAnalytics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelAnalytics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 32:
          if (tag !== 258) {
            break;
          }

          message.params = ChannelAnalytics_Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseChannelAnalytics_Params(): ChannelAnalytics_Params {
  return { channelId: "" };
}

export const ChannelAnalytics_Params: MessageFns<ChannelAnalytics_Params> = {
  encode(message: ChannelAnalytics_Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(8010).string(message.channelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelAnalytics_Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelAnalytics_Params();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1001:
          if (tag !== 8010) {
            break;
          }

          message.channelId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSoundInfoParams(): SoundInfoParams {
  return { sound: undefined };
}

export const SoundInfoParams: MessageFns<SoundInfoParams> = {
  encode(message: SoundInfoParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sound !== undefined) {
      SoundInfoParams_Sound.encode(message.sound, writer.uint32(754).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoundInfoParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoundInfoParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 94:
          if (tag !== 754) {
            break;
          }

          message.sound = SoundInfoParams_Sound.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSoundInfoParams_Sound(): SoundInfoParams_Sound {
  return { params: undefined };
}

export const SoundInfoParams_Sound: MessageFns<SoundInfoParams_Sound> = {
  encode(message: SoundInfoParams_Sound, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      SoundInfoParams_Sound_Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoundInfoParams_Sound {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoundInfoParams_Sound();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.params = SoundInfoParams_Sound_Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSoundInfoParams_Sound_Params(): SoundInfoParams_Sound_Params {
  return { ids: undefined };
}

export const SoundInfoParams_Sound_Params: MessageFns<SoundInfoParams_Sound_Params> = {
  encode(message: SoundInfoParams_Sound_Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ids !== undefined) {
      SoundInfoParams_Sound_Params_Ids.encode(message.ids, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoundInfoParams_Sound_Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoundInfoParams_Sound_Params();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ids = SoundInfoParams_Sound_Params_Ids.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSoundInfoParams_Sound_Params_Ids(): SoundInfoParams_Sound_Params_Ids {
  return { id1: "", id2: "", id3: "" };
}

export const SoundInfoParams_Sound_Params_Ids: MessageFns<SoundInfoParams_Sound_Params_Ids> = {
  encode(message: SoundInfoParams_Sound_Params_Ids, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id1 !== "") {
      writer.uint32(10).string(message.id1);
    }
    if (message.id2 !== "") {
      writer.uint32(18).string(message.id2);
    }
    if (message.id3 !== "") {
      writer.uint32(26).string(message.id3);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoundInfoParams_Sound_Params_Ids {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoundInfoParams_Sound_Params_Ids();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id1 = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id2 = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id3 = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotificationPreferences(): NotificationPreferences {
  return { channelId: "", prefId: undefined, number0: undefined, number1: undefined };
}

export const NotificationPreferences: MessageFns<NotificationPreferences> = {
  encode(message: NotificationPreferences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.prefId !== undefined) {
      NotificationPreferences_Preference.encode(message.prefId, writer.uint32(18).fork()).join();
    }
    if (message.number0 !== undefined) {
      writer.uint32(24).int32(message.number0);
    }
    if (message.number1 !== undefined) {
      writer.uint32(32).int32(message.number1);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationPreferences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationPreferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.prefId = NotificationPreferences_Preference.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.number0 = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.number1 = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotificationPreferences_Preference(): NotificationPreferences_Preference {
  return { index: 0 };
}

export const NotificationPreferences_Preference: MessageFns<NotificationPreferences_Preference> = {
  encode(message: NotificationPreferences_Preference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationPreferences_Preference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationPreferences_Preference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiveMessageParams(): LiveMessageParams {
  return { params: undefined, number0: undefined, number1: undefined };
}

export const LiveMessageParams: MessageFns<LiveMessageParams> = {
  encode(message: LiveMessageParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      LiveMessageParams_Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    if (message.number0 !== undefined) {
      writer.uint32(16).int32(message.number0);
    }
    if (message.number1 !== undefined) {
      writer.uint32(24).int32(message.number1);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveMessageParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveMessageParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.params = LiveMessageParams_Params.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.number0 = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.number1 = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiveMessageParams_Params(): LiveMessageParams_Params {
  return { ids: undefined };
}

export const LiveMessageParams_Params: MessageFns<LiveMessageParams_Params> = {
  encode(message: LiveMessageParams_Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ids !== undefined) {
      LiveMessageParams_Params_Ids.encode(message.ids, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveMessageParams_Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveMessageParams_Params();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ids = LiveMessageParams_Params_Ids.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiveMessageParams_Params_Ids(): LiveMessageParams_Params_Ids {
  return { channelId: "", videoId: "" };
}

export const LiveMessageParams_Params_Ids: MessageFns<LiveMessageParams_Params_Ids> = {
  encode(message: LiveMessageParams_Params_Ids, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.videoId !== "") {
      writer.uint32(18).string(message.videoId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveMessageParams_Params_Ids {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveMessageParams_Params_Ids();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.videoId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetCommentsSectionParams(): GetCommentsSectionParams {
  return { ctx: undefined, unkParam: 0, params: undefined };
}

export const GetCommentsSectionParams: MessageFns<GetCommentsSectionParams> = {
  encode(message: GetCommentsSectionParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ctx !== undefined) {
      GetCommentsSectionParams_Context.encode(message.ctx, writer.uint32(18).fork()).join();
    }
    if (message.unkParam !== 0) {
      writer.uint32(24).int32(message.unkParam);
    }
    if (message.params !== undefined) {
      GetCommentsSectionParams_Params.encode(message.params, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCommentsSectionParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCommentsSectionParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ctx = GetCommentsSectionParams_Context.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.unkParam = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.params = GetCommentsSectionParams_Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetCommentsSectionParams_Context(): GetCommentsSectionParams_Context {
  return { videoId: "" };
}

export const GetCommentsSectionParams_Context: MessageFns<GetCommentsSectionParams_Context> = {
  encode(message: GetCommentsSectionParams_Context, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoId !== "") {
      writer.uint32(18).string(message.videoId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCommentsSectionParams_Context {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCommentsSectionParams_Context();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.videoId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetCommentsSectionParams_Params(): GetCommentsSectionParams_Params {
  return { unkToken: undefined, opts: undefined, repliesOpts: undefined, page: undefined, target: "" };
}

export const GetCommentsSectionParams_Params: MessageFns<GetCommentsSectionParams_Params> = {
  encode(message: GetCommentsSectionParams_Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unkToken !== undefined) {
      writer.uint32(10).string(message.unkToken);
    }
    if (message.opts !== undefined) {
      GetCommentsSectionParams_Params_Options.encode(message.opts, writer.uint32(34).fork()).join();
    }
    if (message.repliesOpts !== undefined) {
      GetCommentsSectionParams_Params_RepliesOptions.encode(message.repliesOpts, writer.uint32(26).fork()).join();
    }
    if (message.page !== undefined) {
      writer.uint32(40).int32(message.page);
    }
    if (message.target !== "") {
      writer.uint32(66).string(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCommentsSectionParams_Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCommentsSectionParams_Params();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.unkToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.opts = GetCommentsSectionParams_Params_Options.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.repliesOpts = GetCommentsSectionParams_Params_RepliesOptions.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.target = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetCommentsSectionParams_Params_Options(): GetCommentsSectionParams_Params_Options {
  return { videoId: "", sortBy: 0, type: 0, commentId: undefined };
}

export const GetCommentsSectionParams_Params_Options: MessageFns<GetCommentsSectionParams_Params_Options> = {
  encode(message: GetCommentsSectionParams_Params_Options, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoId !== "") {
      writer.uint32(34).string(message.videoId);
    }
    if (message.sortBy !== 0) {
      writer.uint32(48).int32(message.sortBy);
    }
    if (message.type !== 0) {
      writer.uint32(120).int32(message.type);
    }
    if (message.commentId !== undefined) {
      writer.uint32(130).string(message.commentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCommentsSectionParams_Params_Options {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCommentsSectionParams_Params_Options();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.videoId = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.sortBy = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.commentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetCommentsSectionParams_Params_RepliesOptions(): GetCommentsSectionParams_Params_RepliesOptions {
  return { commentId: "", unkopts: undefined, channelId: undefined, videoId: "", unkParam1: 0, unkParam2: 0 };
}

export const GetCommentsSectionParams_Params_RepliesOptions: MessageFns<
  GetCommentsSectionParams_Params_RepliesOptions
> = {
  encode(
    message: GetCommentsSectionParams_Params_RepliesOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.commentId !== "") {
      writer.uint32(18).string(message.commentId);
    }
    if (message.unkopts !== undefined) {
      GetCommentsSectionParams_Params_RepliesOptions_UnkOpts.encode(message.unkopts, writer.uint32(34).fork()).join();
    }
    if (message.channelId !== undefined) {
      writer.uint32(42).string(message.channelId);
    }
    if (message.videoId !== "") {
      writer.uint32(50).string(message.videoId);
    }
    if (message.unkParam1 !== 0) {
      writer.uint32(64).int32(message.unkParam1);
    }
    if (message.unkParam2 !== 0) {
      writer.uint32(72).int32(message.unkParam2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCommentsSectionParams_Params_RepliesOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCommentsSectionParams_Params_RepliesOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.commentId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.unkopts = GetCommentsSectionParams_Params_RepliesOptions_UnkOpts.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.videoId = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.unkParam1 = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.unkParam2 = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetCommentsSectionParams_Params_RepliesOptions_UnkOpts(): GetCommentsSectionParams_Params_RepliesOptions_UnkOpts {
  return { unkParam: 0 };
}

export const GetCommentsSectionParams_Params_RepliesOptions_UnkOpts: MessageFns<
  GetCommentsSectionParams_Params_RepliesOptions_UnkOpts
> = {
  encode(
    message: GetCommentsSectionParams_Params_RepliesOptions_UnkOpts,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.unkParam !== 0) {
      writer.uint32(8).int32(message.unkParam);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCommentsSectionParams_Params_RepliesOptions_UnkOpts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCommentsSectionParams_Params_RepliesOptions_UnkOpts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.unkParam = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateCommentParams(): CreateCommentParams {
  return { videoId: "", params: undefined, number: 0 };
}

export const CreateCommentParams: MessageFns<CreateCommentParams> = {
  encode(message: CreateCommentParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoId !== "") {
      writer.uint32(18).string(message.videoId);
    }
    if (message.params !== undefined) {
      CreateCommentParams_Params.encode(message.params, writer.uint32(42).fork()).join();
    }
    if (message.number !== 0) {
      writer.uint32(80).int32(message.number);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCommentParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCommentParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.videoId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.params = CreateCommentParams_Params.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.number = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateCommentParams_Params(): CreateCommentParams_Params {
  return { index: 0 };
}

export const CreateCommentParams_Params: MessageFns<CreateCommentParams_Params> = {
  encode(message: CreateCommentParams_Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCommentParams_Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCommentParams_Params();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePeformCommentActionParams(): PeformCommentActionParams {
  return {
    type: 0,
    commentId: "",
    videoId: "",
    unkNum: undefined,
    channelId: undefined,
    translateCommentParams: undefined,
  };
}

export const PeformCommentActionParams: MessageFns<PeformCommentActionParams> = {
  encode(message: PeformCommentActionParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.commentId !== "") {
      writer.uint32(26).string(message.commentId);
    }
    if (message.videoId !== "") {
      writer.uint32(42).string(message.videoId);
    }
    if (message.unkNum !== undefined) {
      writer.uint32(16).int32(message.unkNum);
    }
    if (message.channelId !== undefined) {
      writer.uint32(186).string(message.channelId);
    }
    if (message.translateCommentParams !== undefined) {
      PeformCommentActionParams_TranslateCommentParams.encode(message.translateCommentParams, writer.uint32(250).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PeformCommentActionParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeformCommentActionParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.commentId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.videoId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.unkNum = reader.int32();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.translateCommentParams = PeformCommentActionParams_TranslateCommentParams.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePeformCommentActionParams_TranslateCommentParams(): PeformCommentActionParams_TranslateCommentParams {
  return { params: undefined, commentId: "", targetLanguage: "" };
}

export const PeformCommentActionParams_TranslateCommentParams: MessageFns<
  PeformCommentActionParams_TranslateCommentParams
> = {
  encode(
    message: PeformCommentActionParams_TranslateCommentParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.params !== undefined) {
      PeformCommentActionParams_TranslateCommentParams_Params.encode(message.params, writer.uint32(26).fork()).join();
    }
    if (message.commentId !== "") {
      writer.uint32(18).string(message.commentId);
    }
    if (message.targetLanguage !== "") {
      writer.uint32(34).string(message.targetLanguage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PeformCommentActionParams_TranslateCommentParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeformCommentActionParams_TranslateCommentParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.params = PeformCommentActionParams_TranslateCommentParams_Params.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.commentId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetLanguage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePeformCommentActionParams_TranslateCommentParams_Params(): PeformCommentActionParams_TranslateCommentParams_Params {
  return { comment: undefined };
}

export const PeformCommentActionParams_TranslateCommentParams_Params: MessageFns<
  PeformCommentActionParams_TranslateCommentParams_Params
> = {
  encode(
    message: PeformCommentActionParams_TranslateCommentParams_Params,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.comment !== undefined) {
      PeformCommentActionParams_TranslateCommentParams_Params_Comment.encode(message.comment, writer.uint32(10).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PeformCommentActionParams_TranslateCommentParams_Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeformCommentActionParams_TranslateCommentParams_Params();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.comment = PeformCommentActionParams_TranslateCommentParams_Params_Comment.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePeformCommentActionParams_TranslateCommentParams_Params_Comment(): PeformCommentActionParams_TranslateCommentParams_Params_Comment {
  return { text: "" };
}

export const PeformCommentActionParams_TranslateCommentParams_Params_Comment: MessageFns<
  PeformCommentActionParams_TranslateCommentParams_Params_Comment
> = {
  encode(
    message: PeformCommentActionParams_TranslateCommentParams_Params_Comment,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): PeformCommentActionParams_TranslateCommentParams_Params_Comment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeformCommentActionParams_TranslateCommentParams_Params_Comment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHashtag(): Hashtag {
  return { params: undefined };
}

export const Hashtag: MessageFns<Hashtag> = {
  encode(message: Hashtag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Hashtag_Params.encode(message.params, writer.uint32(746).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hashtag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashtag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 93:
          if (tag !== 746) {
            break;
          }

          message.params = Hashtag_Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHashtag_Params(): Hashtag_Params {
  return { hashtag: "", type: 0 };
}

export const Hashtag_Params: MessageFns<Hashtag_Params> = {
  encode(message: Hashtag_Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hashtag !== "") {
      writer.uint32(10).string(message.hashtag);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hashtag_Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashtag_Params();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hashtag = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReelSequence(): ReelSequence {
  return { shortId: "", params: undefined, feature2: 0, feature3: 0 };
}

export const ReelSequence: MessageFns<ReelSequence> = {
  encode(message: ReelSequence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shortId !== "") {
      writer.uint32(10).string(message.shortId);
    }
    if (message.params !== undefined) {
      ReelSequence_Params.encode(message.params, writer.uint32(42).fork()).join();
    }
    if (message.feature2 !== 0) {
      writer.uint32(80).int32(message.feature2);
    }
    if (message.feature3 !== 0) {
      writer.uint32(104).int32(message.feature3);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReelSequence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReelSequence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.shortId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.params = ReelSequence_Params.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.feature2 = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.feature3 = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReelSequence_Params(): ReelSequence_Params {
  return { number: 0 };
}

export const ReelSequence_Params: MessageFns<ReelSequence_Params> = {
  encode(message: ReelSequence_Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== 0) {
      writer.uint32(24).int32(message.number);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReelSequence_Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReelSequence_Params();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.number = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseShortsParam(): ShortsParam {
  return { f1: undefined, p59: undefined };
}

export const ShortsParam: MessageFns<ShortsParam> = {
  encode(message: ShortsParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.f1 !== undefined) {
      ShortsParam_Field1.encode(message.f1, writer.uint32(10).fork()).join();
    }
    if (message.p59 !== undefined) {
      writer.uint32(472).int32(message.p59);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShortsParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShortsParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.f1 = ShortsParam_Field1.decode(reader, reader.uint32());
          continue;
        case 59:
          if (tag !== 472) {
            break;
          }

          message.p59 = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseShortsParam_Field1(): ShortsParam_Field1 {
  return { p1: undefined };
}

export const ShortsParam_Field1: MessageFns<ShortsParam_Field1> = {
  encode(message: ShortsParam_Field1, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.p1 !== undefined) {
      writer.uint32(8).int32(message.p1);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShortsParam_Field1 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShortsParam_Field1();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.p1 = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNextParams(): NextParams {
  return { videoId: [] };
}

export const NextParams: MessageFns<NextParams> = {
  encode(message: NextParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.videoId) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NextParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNextParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.videoId.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
